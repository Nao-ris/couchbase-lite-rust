/* automatically generated by rust-bindgen 0.59.1 */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type size_t = __darwin_size_t;
#[doc = " A simple reference to a block of memory. Does not imply ownership."]
#[doc = "(This is equivalent to the C++ class `slice`.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLSlice {
    pub buf: *const ::std::os::raw::c_void,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_FLSlice() {
    assert_eq!(
        ::std::mem::size_of::<FLSlice>(),
        16usize,
        concat!("Size of: ", stringify!(FLSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<FLSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(FLSlice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLSlice>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLSlice),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLSlice>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLSlice),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " A heap-allocated block of memory returned from an API call."]
#[doc = "The caller takes ownership, and must call \\ref FLSliceResult_Release when done with it."]
#[doc = "\\warning The contents of the block must not be modified, since others may be using it."]
#[doc = "\\note This is equivalent to the C++ class `alloc_slice`. In C++ the easiest way to deal with"]
#[doc = "a `FLSliceResult` return value is to construct an `alloc_slice` from it, which will"]
#[doc = "adopt the reference, and release it in its destructor. For example:"]
#[doc = "`alloc_slice foo( CopyFoo() );`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLSliceResult {
    pub buf: *const ::std::os::raw::c_void,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_FLSliceResult() {
    assert_eq!(
        ::std::mem::size_of::<FLSliceResult>(),
        16usize,
        concat!("Size of: ", stringify!(FLSliceResult))
    );
    assert_eq!(
        ::std::mem::align_of::<FLSliceResult>(),
        8usize,
        concat!("Alignment of ", stringify!(FLSliceResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLSliceResult>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLSliceResult),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FLSliceResult>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLSliceResult),
            "::",
            stringify!(size)
        )
    );
}
pub type FLString = FLSlice;
pub type FLStringResult = FLSliceResult;
#[doc = " Error domains, serving as namespaces for numeric error codes."]
pub type CBLErrorDomain = u8;
#[doc = " A struct holding information about an error. It's declared on the stack by a caller, and"]
#[doc = "its address is passed to an API function. If the function's return value indicates that"]
#[doc = "there was an error (usually by returning NULL or false), then the CBLError will have been"]
#[doc = "filled in with the details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLError {
    #[doc = "< Domain of errors; a namespace for the `code`."]
    pub domain: CBLErrorDomain,
    #[doc = "< Error code, specific to the domain. 0 always means no error."]
    pub code: ::std::os::raw::c_int,
    pub internal_info: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CBLError() {
    assert_eq!(
        ::std::mem::size_of::<CBLError>(),
        12usize,
        concat!("Size of: ", stringify!(CBLError))
    );
    assert_eq!(
        ::std::mem::align_of::<CBLError>(),
        4usize,
        concat!("Alignment of ", stringify!(CBLError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBLError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBLError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBLError>())).internal_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLError),
            "::",
            stringify!(internal_info)
        )
    );
}
extern "C" {
    #[doc = " Returns a message describing an error."]
    #[doc = "@note  You are responsible for releasing the result by calling \\ref FLSliceResult_Release."]
    pub fn CBLError_Message(outError: *const CBLError) -> FLSliceResult;
}
#[doc = " A date/time representation used for document expiration (and in date/time queries.)"]
#[doc = "Measured in milliseconds since the Unix epoch (1/1/1970, midnight UTC.)"]
pub type CBLTimestamp = i64;
extern "C" {
    #[doc = " Returns the current time, in milliseconds since 1/1/1970."]
    pub fn CBL_Now() -> CBLTimestamp;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLRefCounted {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Increments an object's reference-count."]
    #[doc = "Usually you'll call one of the type-safe synonyms specific to the object type,"]
    #[doc = "like \\ref CBLDatabase_Retain`"]
    pub fn CBL_Retain(arg1: *mut CBLRefCounted) -> *mut CBLRefCounted;
}
extern "C" {
    #[doc = " Decrements an object's reference-count, freeing the object if the count hits zero."]
    #[doc = "Usually you'll call one of the type-safe synonyms specific to the object type,"]
    #[doc = "like \\ref CBLDatabase_Release."]
    pub fn CBL_Release(arg1: *mut CBLRefCounted);
}
extern "C" {
    #[doc = " Returns the total number of Couchbase Lite objects. Useful for leak checking."]
    pub fn CBL_InstanceCount() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Logs the class and address of each Couchbase Lite object. Useful for leak checking."]
    #[doc = "@note  May only be functional in debug builds of Couchbase Lite."]
    pub fn CBL_DumpInstances();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLDatabase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLListenerToken {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Removes a listener callback, given the token that was returned when it was added."]
    pub fn CBLListener_Remove(arg1: *mut CBLListenerToken);
}
#[doc = " Database encryption algorithms (available only in the Enterprise Edition)."]
pub type CBLEncryptionAlgorithm = u32;
#[doc = " Encryption key specified in a \\ref CBLDatabaseConfiguration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLEncryptionKey {
    #[doc = "< Encryption algorithm"]
    pub algorithm: CBLEncryptionAlgorithm,
    #[doc = "< Raw key data"]
    pub bytes: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_CBLEncryptionKey() {
    assert_eq!(
        ::std::mem::size_of::<CBLEncryptionKey>(),
        36usize,
        concat!("Size of: ", stringify!(CBLEncryptionKey))
    );
    assert_eq!(
        ::std::mem::align_of::<CBLEncryptionKey>(),
        4usize,
        concat!("Alignment of ", stringify!(CBLEncryptionKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBLEncryptionKey>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLEncryptionKey),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBLEncryptionKey>())).bytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLEncryptionKey),
            "::",
            stringify!(bytes)
        )
    );
}
#[doc = " Database configuration options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLDatabaseConfiguration {
    #[doc = "< The parent directory of the database"]
    pub directory: FLString,
    #[doc = "< The database's encryption key (if any)"]
    pub encryptionKey: CBLEncryptionKey,
}
#[test]
fn bindgen_test_layout_CBLDatabaseConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<CBLDatabaseConfiguration>(),
        56usize,
        concat!("Size of: ", stringify!(CBLDatabaseConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<CBLDatabaseConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLDatabaseConfiguration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBLDatabaseConfiguration>())).directory as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLDatabaseConfiguration),
            "::",
            stringify!(directory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBLDatabaseConfiguration>())).encryptionKey as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLDatabaseConfiguration),
            "::",
            stringify!(encryptionKey)
        )
    );
}
extern "C" {
    #[doc = " Returns the default database configuration."]
    pub fn CBLDatabaseConfiguration_Default() -> CBLDatabaseConfiguration;
}
extern "C" {
    #[doc = " Derives an encryption key from a password. If your UI uses passwords, call this function to"]
    #[doc = "create the key used to encrypt the database. It is designed for security, and deliberately"]
    #[doc = "runs slowly to make brute-force attacks impractical."]
    #[doc = "@param key  The derived AES key will be stored here."]
    #[doc = "@param password  The input password, which can be any data."]
    #[doc = "@return  True on success, false if there was a problem deriving the key."]
    pub fn CBLEncryptionKey_FromPassword(key: *mut CBLEncryptionKey, password: FLString) -> bool;
}
extern "C" {
    #[doc = " Returns true if a database with the given name exists in the given directory."]
    #[doc = "@param name  The database name (without the \".cblite2\" extension.)"]
    #[doc = "@param inDirectory  The directory containing the database. If NULL, `name` must be an"]
    #[doc = "absolute or relative path to the database."]
    pub fn CBL_DatabaseExists(name: FLString, inDirectory: FLString) -> bool;
}
extern "C" {
    #[doc = " Copies a database file to a new location, and assigns it a new internal UUID to distinguish"]
    #[doc = "it from the original database when replicating."]
    #[doc = "@param fromPath  The full filesystem path to the original database (including extension)."]
    #[doc = "@param toName  The new database name (without the \".cblite2\" extension.)"]
    #[doc = "@param config  The database configuration (directory and encryption option.)"]
    #[doc = "@param outError  On return, will be set to the error that occurred, if applicable."]
    pub fn CBL_CopyDatabase(
        fromPath: FLString,
        toName: FLString,
        config: *const CBLDatabaseConfiguration,
        outError: *mut CBLError,
    ) -> bool;
}
extern "C" {
    #[doc = " Deletes a database file. If the database file is open, an error is returned."]
    #[doc = "@param name  The database name (without the \".cblite2\" extension.)"]
    #[doc = "@param inDirectory  The directory containing the database. If NULL, `name` must be an"]
    #[doc = "absolute or relative path to the database."]
    #[doc = "@param outError  On return, will be set to the error that occurred, or a 0 code if no error."]
    #[doc = "@return  True if the database was deleted, false if it doesn't exist or deletion failed."]
    #[doc = "(You can tell the last two cases apart by looking at \\p outError.)"]
    pub fn CBL_DeleteDatabase(
        name: FLString,
        inDirectory: FLString,
        outError: *mut CBLError,
    ) -> bool;
}
extern "C" {
    #[doc = " Opens a database, or creates it if it doesn't exist yet, returning a new \\ref CBLDatabase"]
    #[doc = "instance."]
    #[doc = "It's OK to open the same database file multiple times. Each \\ref CBLDatabase instance is"]
    #[doc = "independent of the others (and must be separately closed and released.)"]
    #[doc = "@param name  The database name (without the \".cblite2\" extension.)"]
    #[doc = "@param config  The database configuration (directory and encryption option.)"]
    #[doc = "@param outError  On failure, the error will be written here."]
    #[doc = "@return  The new database object, or NULL on failure."]
    pub fn CBLDatabase_Open(
        name: FLSlice,
        config: *const CBLDatabaseConfiguration,
        outError: *mut CBLError,
    ) -> *mut CBLDatabase;
}
extern "C" {
    #[doc = " Closes an open database."]
    pub fn CBLDatabase_Close(arg1: *mut CBLDatabase, outError: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Closes and deletes a database. If there are any other connections to the database,"]
    #[doc = "an error is returned."]
    pub fn CBLDatabase_Delete(arg1: *mut CBLDatabase, outError: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Begins a transaction. You **must** later call \\ref"]
    #[doc = "CBLDatabase_EndTransaction to commit or abort the transaction."]
    #[doc = "@note  Multiple writes are much faster when grouped in a transaction."]
    #[doc = "@note  Changes will not be visible to other CBLDatabase instances on the same database until"]
    #[doc = "the transaction ends."]
    #[doc = "@note  Transactions can nest. Changes are not committed until the outer transaction ends."]
    pub fn CBLDatabase_BeginTransaction(arg1: *mut CBLDatabase, outError: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Ends a transaction, either committing or aborting."]
    pub fn CBLDatabase_EndTransaction(
        arg1: *mut CBLDatabase,
        commit: bool,
        outError: *mut CBLError,
    ) -> bool;
}
extern "C" {
    #[doc = " Encrypts or decrypts a database, or changes its encryption key."]
    #[doc = ""]
    #[doc = "If \\p newKey is NULL, or its \\p algorithm is \\ref kCBLEncryptionNone, the database will be decrypted."]
    #[doc = "Otherwise the database will be encrypted with that key; if it was already encrypted, it will be"]
    #[doc = "re-encrypted with the new key."]
    pub fn CBLDatabase_ChangeEncryptionKey(
        arg1: *mut CBLDatabase,
        newKey: *const CBLEncryptionKey,
        outError: *mut CBLError,
    ) -> bool;
}
#[doc = " Maintenance Type used when performing database maintenance."]
pub type CBLMaintenanceType = u32;
extern "C" {
    #[doc = "  Performs database maintenance."]
    pub fn CBLDatabase_PerformMaintenance(
        db: *mut CBLDatabase,
        type_: CBLMaintenanceType,
        outError: *mut CBLError,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the database's name."]
    pub fn CBLDatabase_Name(arg1: *const CBLDatabase) -> FLString;
}
extern "C" {
    #[doc = " Returns the database's full filesystem path."]
    pub fn CBLDatabase_Path(arg1: *const CBLDatabase) -> FLStringResult;
}
extern "C" {
    #[doc = " Returns the number of documents in the database."]
    pub fn CBLDatabase_Count(arg1: *const CBLDatabase) -> u64;
}
extern "C" {
    #[doc = " Returns the database's configuration, as given when it was opened."]
    #[doc = "@note  The encryption key is not filled in, for security reasons."]
    pub fn CBLDatabase_Config(arg1: *const CBLDatabase) -> CBLDatabaseConfiguration;
}
#[doc = " A database change listener callback, invoked after one or more documents are changed on disk."]
#[doc = "@warning  By default, this listener may be called on arbitrary threads. If your code isn't"]
#[doc = "prepared for that, you may want to use \\ref CBLDatabase_BufferNotifications"]
#[doc = "so that listeners will be called in a safe context."]
#[doc = "@param context  An arbitrary value given when the callback was registered."]
#[doc = "@param db  The database that changed."]
#[doc = "@param numDocs  The number of documents that changed (size of the `docIDs` array)"]
#[doc = "@param docIDs  The IDs of the documents that changed, as a C array of `numDocs` C strings."]
pub type CBLDatabaseChangeListener = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        db: *const CBLDatabase,
        numDocs: ::std::os::raw::c_uint,
        docIDs: *mut FLString,
    ),
>;
extern "C" {
    #[doc = " Registers a database change listener callback. It will be called after one or more"]
    #[doc = "documents are changed on disk."]
    #[doc = "@param db  The database to observe."]
    #[doc = "@param listener  The callback to be invoked."]
    #[doc = "@param context  An opaque value that will be passed to the callback."]
    #[doc = "@return  A token to be passed to \\ref CBLListener_Remove when it's time to remove the"]
    #[doc = "listener."]
    pub fn CBLDatabase_AddChangeListener(
        db: *const CBLDatabase,
        listener: CBLDatabaseChangeListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
#[doc = " Callback indicating that the database (or an object belonging to it) is ready to call one"]
#[doc = "or more listeners. You should call \\ref CBLDatabase_SendNotifications at your earliest"]
#[doc = "convenience, in the context (thread, dispatch queue, etc.) you want them to run."]
#[doc = "@note  This callback is called _only once_ until the next time \\ref CBLDatabase_SendNotifications"]
#[doc = "is called. If you don't respond by (sooner or later) calling that function,"]
#[doc = "you will not be informed that any listeners are ready."]
#[doc = "@warning  This can be called from arbitrary threads. It should do as little work as"]
#[doc = "possible, just scheduling a future call to \\ref CBLDatabase_SendNotifications."]
pub type CBLNotificationsReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, db: *mut CBLDatabase),
>;
extern "C" {
    #[doc = " Switches the database to buffered-notification mode. Notifications for objects belonging"]
    #[doc = "to this database (documents, queries, replicators, and of course the database) will not be"]
    #[doc = "called immediately; your \\ref CBLNotificationsReadyCallback will be called instead."]
    #[doc = "@param db  The database whose notifications are to be buffered."]
    #[doc = "@param callback  The function to be called when a notification is available."]
    #[doc = "@param context  An arbitrary value that will be passed to the callback."]
    pub fn CBLDatabase_BufferNotifications(
        db: *mut CBLDatabase,
        callback: CBLNotificationsReadyCallback,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Immediately issues all pending notifications for this database, by calling their listener"]
    #[doc = "callbacks."]
    pub fn CBLDatabase_SendNotifications(db: *mut CBLDatabase);
}